# dungeon_in_1983

문제를 받으면 이런 형태의 프로그램이 있다.
![/Pwn-reverse/dungeon/images/image1.png](image1.png)
Radare2로 분석해보면 main 함수가 굉장히 길게 나온다. 하지만 지금 중요한 부분은 여기다. Fcn.1407을 실행하고 그 반환값에 따라서 패배냐 클리어냐가 결정난다. 화면에서는 잘렸지만 rdi는 우리가 넣은 입력값, rsi는 알 수 없는 어떤 주소 내부의 값이다.

함수 내부로 들어가보자.

시작 부분이다. Rdi가 var_28, rsi가 var_30에 입력된다. 그리고 var_28의 값과 var_ch의 값을 서로 더한 다음 가장 아래 값이 A와 B 중 어느 것인가에 따라 분기가 생긴다. 여기서 var_ch가 index라고 유추할 수 있다.
먼저 A를 보겠다.
![Pwn-reverse/dungeon/image/image1.png](image1.png)

먼저 var_10을 1로 바꾸고 var_8에 1을 더한다. Var_14를 0과 비교한 후 같다면 0x1487로 분기한다.

만약 0이 아닐 경우 “버튼이 꼈다” 라는 문장이 나오고 프로그램을 종료한다. 여기서 var_14는 버튼을 연속으로 입력했을 때를 감지하는 변수라고 유추할 수 있다.

여기서 var_14를 1로 바꾼다.

여기서는 var_ch에 1을 더한다. 그 다음 var_28과 더하고 제일 아래가 0인지 확인한다. 아니라면 2번째 사진(아까 a와 b의 분기가 있었던 부분)으로 점프한다. 즉, 문자열 끝이 아니면 과정을 반복한다. 여기서 var_ch가 index가 맞다는 것을 알 수 있다.
이번에는 B일 때를 살펴보겠다.
![dungeon/image/image2.png](image2.png)

Var_10에 저장된 값을 0과 비교한다. 0이 아니라면 분기한다.

분기하지 않는다면 문자열을 출력하고 프로그램을 종료한다. 문자열의 내용으로 보아 B가 맨 앞에 오면 일어나는 분기라고 추정할 수 있다. 맨 처음에 var_10을 0으로 설정하고 A분기에서 var_10을 1로 바꾼다. 즉, 이 추정은 정확하다.

Var_8에 2를 곱하고 var_14를 0으로 바꾼다. A분기에서 var_14를 버튼을 연타했을 때를 감지하는 변수라고 추정했었다. 현재 B분기에서는 var_14의 값을 감지하는 코드가 없다. 따라서 B버튼 연타를 감지하는 변수는 아니다. 그리고 지금 B분기에서 var_14가 0이 되는 것을 보면 A버튼 연타를 감지하기 위한 코드로 보인다.

B분기의 경우도 A분기와 동일한 연산을 한다. 이제 이 반복문이 끝나는 조건을 살펴보자. 문자열의 끝에 도달하면 반복문이 끝나는데, var_8과 var_30이 같으면 1, 다르면 0을 반환한다.
간단히 정리하면, 이 함수는 입력한 문자열을 하나씩 순회하며 A라면 var_8+1, B라면 var_8*2를 하고 var_8이 var_30, 즉 2번째 인자와 같으면 1을 반환하고 아니면 0을 반환하는 함수이다.
아까 위에서 본 2번째 인자는 [ptr]이라는 알 수 없는 주소의 값이었다. 이제 이 주소가 어떻게 정해지는지를 찾아보겠다.

Main 함수를 살펴보면 여기서 /dev/urandom을 연다.
![dungeon/image/image3.png](image3.png)

그리고 그 내부의 값을 읽어서 [ptr]에 쓴다. 그럼 이 값에 대한 단서는 없을까?

이 함수에서 [ptr]을 첫 번째 인자로 가져간다. 한 번 분석해보자.
![dungeon/image/image4.png](image4.png)


첫 번째 인자를 rdi에 넣고 오른쪽으로 비트 단위 이동을 한다. 0, 0x8, 0x10, 0x18, 0x20, 0x28, 0x30만큼의 이동을 시킨다. 마지막 0x30은 ax이므로 혼자 2바이트이다. 그리고 이 값이 각각의 스탯이 된다. 간단히 말하면 0-8번째 비트, 8-16번째 비트, 16-24번째 비트….이런 식으로 스탯이 된다는 것이다. 원 값을 복원하기 위해서는 이 비트들이 원래 자리로 가게끔 왼쪽으로 비트 단위 이동을 한 후 다 더해주면 된다.
그 다음 A와 B를 계산해서 원 값과 동일한 값이 나오게 만들어주면 된다.

이런 식으로 익스플로잇을 짜 주면 된다. 사실 이 A와 B를 이용한 연산은 2진수 연산과 완전히 동일하다. 그래서 이렇게 짤 필요 없이 원 값을 이진수로 바꾸면 훨씬 쉽게 풀 수 있다.
